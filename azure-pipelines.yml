trigger:
  branches:
    include: ["master", "*"]  
  paths:
    exclude: ["doc", "*.md", ".appveyor.yml"]

pr:
  branches:
    include: [ "*" ]

jobs:

#################
# STM32
- job: Build_STM32_targets
  # skip build if this is a PR, submitted by nfbot and the commit message contains [version update]
  condition: not( and( eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.RequestedForId'], 'nfbot'), contains(variables['Build.SourceVersionMessage'], '[version update]') ) )
  pool:
    vmImage: 'VS2017-Win2016'

  strategy:
    matrix:
      MBN_QUAIL:
        BoardName: MBN_QUAIL
        BuildOptions: -DTARGET_SERIES=STM32F4xx -DRTOS=CHIBIOS -DSUPPORT_ANY_BASE_CONVERSION=ON -DNF_FEATURE_DEBUGGER=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON
        NeedsDFU: true
      NETDUINO3_WIFI:
        BoardName: NETDUINO3_WIFI
        BuildOptions: -DTARGET_SERIES=STM32F4xx -DRTOS=CHIBIOS -DSUPPORT_ANY_BASE_CONVERSION=ON -DNF_FEATURE_DEBUGGER=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON
        NeedsDFU: true
      ST_STM32F429I_DISCOVERY:
        BoardName: ST_STM32F429I_DISCOVERY
        BuildOptions: -DTARGET_SERIES=STM32F4xx -DRTOS=CHIBIOS -DSUPPORT_ANY_BASE_CONVERSION=ON -DNF_FEATURE_DEBUGGER=ON -DSWO_OUTPUT=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON
        NeedsDFU: false
      ST_STM32F4_DISCOVERY:
        BoardName: ST_STM32F4_DISCOVERY
        BuildOptions: -DTARGET_SERIES=STM32F4xx -DRTOS=CHIBIOS -DSUPPORT_ANY_BASE_CONVERSION=ON -DNF_FEATURE_DEBUGGER=ON -DSWO_OUTPUT=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON
        NeedsDFU: false
      ST_NUCLEO64_F091RC:
        BoardName: ST_NUCLEO64_F091RC
        BuildOptions: -DTARGET_SERIES=STM32F0xx -DRTOS=CHIBIOS -DNF_FEATURE_DEBUGGER=ON -DNF_FEATURE_RTC=ON -DUSE_RNG=OFF -DNF_PLATFORM_NO_CLR_TRACE=ON -DNF_CLR_NO_IL_INLINE=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON
        NeedsDFU: false
      ST_NUCLEO144_F746ZG:
        BoardName: ST_NUCLEO144_F746ZG 
        BuildOptions: -DTARGET_SERIES=STM32F7xx -DRTOS=CHIBIOS -DNF_FEATURE_DEBUGGER=ON -DSWO_OUTPUT=ON -DNF_FEATURE_RTC=ON -DNF_FEATURE_HAS_CONFIG_BLOCK=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON -DAPI_System.Net=ON -DNF_SECURITY_MBEDTLS=ON
        NeedsDFU: false
      ST_STM32F769I_DISCOVERY:
        BoardName: ST_STM32F769I_DISCOVERY
        BuildOptions: -DTARGET_SERIES=STM32F7xx -DRTOS=CHIBIOS -DSUPPORT_ANY_BASE_CONVERSION=ON -DNF_FEATURE_DEBUGGER=ON -DSWO_OUTPUT=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Hardware.Stm32=ON -DNF_FEATURE_HAS_CONFIG_BLOCK=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON -DAPI_System.Net=ON -DNF_SECURITY_MBEDTLS=ON
        NeedsDFU: false     

  variables:
    GNU_GCC_TOOLCHAIN_PATH: $(Agent.TempDirectory)\GNU_Tools_ARM_Embedded

  steps:
  - task: DotNetCoreCLI@2  
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . nbgv
    displayName: Install NBGV tool

  - script: nbgv cloud -a -c
    displayName: Set build number
    condition: ne(variables['system.pullrequest.isfork'], true)

  # Currently Azure pipelines won't let PRs from forks setting the build ID
  # so we need to come up with a versiom number to use for the build
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: Write-Host "$("##vso[task.setvariable variable=NBGV_Version]")0.0.0.$env:System_PullRequest_PullRequestNumber"
    condition: eq(variables['system.pullrequest.isfork'], true)
    displayName: Set temporary build number

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading ARM GNU GCC toolchain..."
            $url = "https://bintray.com/nfbot/internal-build-tools/download_file?file_path=gcc-arm-none-eabi-7-2018-q2-update-win32.7z"
            $output = "$PSScriptRoot\gcc-arm.7z"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Downloading ARM GCC toolchain

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\gcc-arm.7z' 
      destinationFolder: '$(Agent.TempDirectory)\GNU_Tools_ARM_Embedded' 
    displayName: Extracting ARM GCC toolchain

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading Ninja..."
            $url = "https://github.com/ninja-build/ninja/releases/download/v1.8.2/ninja-win.zip"
            $output = "$PSScriptRoot\ninja.zip"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Download Ninja

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\ninja.zip' 
      destinationFolder: '$(Agent.TempDirectory)\ninja' 
    displayName: Extract Ninja

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading hex2dfu..."
            $url = "https://github.com/nanoframework/nf-tools/releases/download/v1.0.0/hex2dfu.exe"
            $output = "$env:Agent_TempDirectory\hex2dfu.exe"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Install HEX2DFU
    condition: eq(variables['NeedsDFU'], true)

  - script: |
        echo "##vso[task.prependpath]$(Agent.TempDirectory)\ninja"
        echo "##vso[task.prependpath]C:\Windows\System32"
    displayName: Tweak PATH

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            $newPath = "$env:Agent_TempDirectory".Replace('\','/')
            Write-Host "$("##vso[task.setvariable variable=HEX2DFU_PATH]")$newPath"
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Adjust HexDFU path
    condition: eq(variables['NeedsDFU'], true)

  - task: CMake@1
    inputs:
      cmakeArgs: '-G Ninja -DTOOLCHAIN_PREFIX=$(GNU_GCC_TOOLCHAIN_PATH) -DCMAKE_BUILD_TYPE=MinSizeRel -DBUILD_VERSION=$(NBGV_Version) -DCHIBIOS_BOARD=$(BoardName) $(BuildOptions) -DTOOL_HEX2DFU_PREFIX=$(HEX2DFU_PATH) ..'
    displayName: Setup build with CMake and DFU
    condition: eq(variables['NeedsDFU'], true)

  - task: CMake@1
    inputs:
      cmakeArgs: '-G Ninja -DTOOLCHAIN_PREFIX=$(GNU_GCC_TOOLCHAIN_PATH) -DCMAKE_BUILD_TYPE=MinSizeRel -DBUILD_VERSION=$(NBGV_Version) -DCHIBIOS_BOARD=$(BoardName) $(BuildOptions) ..'
    displayName: Setup build with CMake without DFU
    condition: eq(variables['NeedsDFU'], false)

  - task: CMake@1
    inputs:
      cmakeArgs: '--build $(Build.SourcesDirectory)\build --target all --config MinSizeRel'
    displayName: Build with CMake

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(Build.SourcesDirectory)\build
      Contents: |
        *.bin
        *.hex
        *.s19
        *.dfu
      TargetFolder: '$(Build.ArtifactStagingDirectory)\$(BoardName)'
      flattenFolders: true
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest') )
    displayName: Collecting deployable artifacts

  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\$(BoardName)'
      ArtifactName: $(BoardName)
      ArtifactType: Container
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest') )
    displayName: Publish deployables artifacts

  - task: ArchiveFiles@2
    inputs:
      rootFolderOrFile: '$(Build.ArtifactStagingDirectory)\$(BoardName)' 
      includeRootFolder: false
      archiveType: 'zip'
      archiveFile: '$(Agent.TempDirectory)\$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip'
      replaceExistingArchive: true
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Zip binary files

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            if( $env:Build_SourceBranchName -eq "develop" -or 
                $env:Build_SourceBranchName -match "^release*" )
            {
              # this a dev or release branch, publish to Bintray dev repo
              Write-Host "$("##vso[task.setvariable variable=BINTRAY_REPO]")nanoframework-images-dev"
            }
            else 
            {
              # this master branch, publish to Bintray stable repo
              Write-Host "$("##vso[task.setvariable variable=BINTRAY_REPO]")nanoframework-images"
            }
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Set Bintray repo path

  - task: cURLUploader@2
    inputs:
      files: '$(Agent.TempDirectory)\$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip'
      authType: 'userAndPass'
      username: 'nfbot'
      password: '$(BinTrayKey)'
      url: 'https://api.bintray.com/'
      remotePath: 'content/nfbot/$(BINTRAY_REPO)/$(BoardName)/$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion)/$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip;publish=1'
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Upload artifact to Bintray

#################
# ESP32 targets
- job: Build_ESP32_targets
  # skip build if this is a PR, submitted by nfbot and the commit message contains [version update]
  condition: not( and( eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.RequestedForId'], 'nfbot'), contains(variables['Build.SourceVersionMessage'], '[version update]') ) )
  pool:
    vmImage: 'VS2017-Win2016'

  # there is only a single ESP32 target, but this is already config as a matrix to make it easy to add new ones
  strategy:
    matrix:
      ESP32_DEVKITC:
        BoardName: ESP32_DEVKITC
        BuildOptions: -DTARGET_SERIES=ESP32 -DRTOS=FREERTOS -DNF_WP_IMPLEMENTS_CRC32=OFF -DNF_FEATURE_DEBUGGER=ON -DNF_FEATURE_RTC=ON -DAPI_System.Math=ON -DAPI_Windows.Devices.Gpio=ON -DAPI_Windows.Devices.Spi=ON -DAPI_Windows.Devices.I2c=ON -DAPI_Windows.Devices.Pwm=ON -DAPI_Windows.Devices.SerialCommunication=ON -DAPI_Windows.Devices.Adc=ON -DAPI_System.Net=ON -DAPI_Windows.Devices.Wifi=ON -DNF_SECURITY_OPENSSL=ON -DAPI_Hardware.Esp32=ON -DSUPPORT_ANY_BASE_CONVERSION=ON

  variables:
    ESP32_TOOLCHAIN_PATH: $(Agent.TempDirectory)\ESP32_Tools

  steps:
  - task: DotNetCoreCLI@2  
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . nbgv
    displayName: Install NBGV tool

  - script: nbgv cloud -a -c
    displayName: Set build number
    condition: ne(variables['system.pullrequest.isfork'], true)

  # Currently Azure pipelines won't let PRs from forks setting the build ID
  # so we need to come up with a versiom number to use for the build
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: Write-Host "$("##vso[task.setvariable variable=NBGV_Version]")0.0.0.$env:System_PullRequest_PullRequestNumber"
    condition: eq(variables['system.pullrequest.isfork'], true)
    displayName: Set temporary build number

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading Xtensa ESP32 toolchain..."
            $url = "https://dl.espressif.com/dl/xtensa-esp32-elf-win32-1.22.0-80-g6c4433a-5.2.0.zip"
            $output = "$PSScriptRoot\xtensa-esp32-elf-win32.zip"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Download xtensa ESP32 toolchain

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\xtensa-esp32-elf-win32.zip' 
      destinationFolder: '$(Agent.TempDirectory)\ESP32_Tools'
      cleanDestinationFolder: false
    displayName: Extracting xtensa ESP32 toolchain

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading Ninja..."
            $url = "https://github.com/ninja-build/ninja/releases/download/v1.8.2/ninja-win.zip"
            $output = "$PSScriptRoot\ninja.zip"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Download Ninja

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\ninja.zip' 
      destinationFolder: '$(Agent.TempDirectory)\ninja' 
    displayName: Extract Ninja

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading ESP32 pre-compiled libs..."
            $url = "https://bintray.com/nfbot/internal-build-tools/download_file?file_path=IDF_libs-v3.1.zip"
            $output = "$PSScriptRoot\IDF_libs-v3.1.zip"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Downloading ESP32 pre-compiled libs

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\IDF_libs-v3.1.zip' 
      destinationFolder: '$(Agent.TempDirectory)\ESP32_Tools\libs-v3.1'
      cleanDestinationFolder: false
    displayName: Installing ESP32 pre-compiled libs

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "Downloading ESP32 IDF..."
            $url = "https://github.com/espressif/esp-idf/releases/download/v3.1/esp-idf-v3.1.zip"
            $output = "$PSScriptRoot\esp-idf-v3.1.zip"
            (New-Object Net.WebClient).DownloadFile($url, $output)
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Downloading ESP32 IDF

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Agent.TempDirectory)\esp-idf-v3.1.zip' 
      destinationFolder: '$(Agent.TempDirectory)\ESP32_Tools'
      cleanDestinationFolder: false
    displayName: Installing Espressif IDF

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: python -m pip install pyserial
        # the bellow settings are required as the script is installing an outdated version of pyserial
        errorActionPreference: 'silentlyContinue' 
        failOnStderr: false
        ignoreLASTEXITCODE: false
    displayName: Installing python pyserial

  - script: |
        echo "##vso[task.prependpath]$(Agent.TempDirectory)\ninja"
        echo "##vso[task.prependpath]C:\Windows\System32"
    displayName: Tweak PATH

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            # need to replace forward slash for paths to work with GCC and CMake
            $tempDirPath = "$env:Agent_TempDirectory".Replace('\','/')
            Write-Host "$("##vso[task.setvariable variable=ESP32_LIBS_PATH]")$tempDirPath/ESP32_Tools/libs-v3.1"
            Write-Host "$("##vso[task.setvariable variable=ESP32_IDF_PATH]")$tempDirPath/ESP32_Tools/esp-idf-v3.1"
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    displayName: Adjust paths

  - task: CMake@1
    inputs:
      cmakeArgs: '-G Ninja -DTOOLCHAIN_PREFIX=$(ESP32_TOOLCHAIN_PATH) -DESP32_IDF_PATH=$(ESP32_IDF_PATH) -DESP32_LIBS_PATH=$(ESP32_LIBS_PATH) -DCMAKE_BUILD_TYPE=MinSizeRel -DBUILD_VERSION=$(NBGV_Version) $(BuildOptions) ..'
    displayName: Setup build with CMake

  - task: CMake@1
    inputs:
      cmakeArgs: '--build $(Build.SourcesDirectory)\build --target all --config MinSizeRel'
    displayName: Build with CMake

  - task: PythonScript@0
    inputs:
      scriptSource: 'filePath'
      scriptPath: '$(Agent.TempDirectory)\ESP32_Tools\esp-idf-v3.1\components\esptool_py\esptool\esptool.py'
      arguments: '--chip esp32 elf2image --flash_mode dio --flash_freq 40m --flash_size 4MB -o $(Build.SourcesDirectory)\build\nanoCLR.bin $(Build.SourcesDirectory)\build\targets\FreeRTOS\ESP32_DevKitC\nanoCLR.elf'
    condition: succeeded()
    displayName: Generate nanoCLR bin file for deployment

  # because of permission issues (the python script isn't allowed to write on the output folder)
  # we need to perform these steps by calling directly the python scripts
  - task: PythonScript@0
    inputs:
      scriptSource: 'filePath'
      scriptPath: '$(Agent.TempDirectory)\ESP32_Tools\esp-idf-v3.1\components\partition_table\gen_esp32part.py'
      arguments: '--verify $(Build.SourcesDirectory)\targets\FreeRTOS\ESP32_DevKitC\IDF\partitions_nanoclr_4mb.csv $(Build.SourcesDirectory)\build\partitions_4mb.bin'
    condition: succeeded()
    displayName: Generate Esp32 Partition tables for 4MB flash

  - task: PythonScript@0
    inputs:
      scriptSource: 'filePath'
      scriptPath: '$(Agent.TempDirectory)\ESP32_Tools\esp-idf-v3.1\components\partition_table\gen_esp32part.py'
      arguments: '--verify $(Build.SourcesDirectory)\targets\FreeRTOS\ESP32_DevKitC\IDF\partitions_nanoclr_2mb.csv $(Build.SourcesDirectory)\build\partitions_2mb.bin'
    condition: succeeded()
    displayName: Generate Esp32 Partition tables for 2MB flash

  - task: PythonScript@0
    inputs:
      scriptSource: 'filePath'
      scriptPath: '$(Agent.TempDirectory)\ESP32_Tools\esp-idf-v3.1\components\partition_table\gen_esp32part.py'
      arguments: '$(Build.SourcesDirectory)\build\partitions_2mb.bin'
    condition: succeeded()
    displayName: List flash 4Mb Esp32 Partition tables

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(Build.SourcesDirectory)\build
      Contents: |
        *.bin
      TargetFolder: '$(Build.ArtifactStagingDirectory)\$(BoardName)'
      flattenFolders: true
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest') )
    displayName: Collecting deployable artifacts

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(ESP32_LIBS_PATH)
      Contents: |
        bootloader.bin
      TargetFolder: '$(Build.ArtifactStagingDirectory)\$(BoardName)'
      flattenFolders: true
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest') )
    displayName: Copying bootloader from ESP32 libs

  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\$(BoardName)'
      ArtifactName: $(BoardName)
      ArtifactType: Container
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest') )
    displayName: Publish deployables artifacts

  - task: ArchiveFiles@2
    inputs:
      rootFolderOrFile: '$(Build.ArtifactStagingDirectory)\$(BoardName)' 
      includeRootFolder: false
      archiveType: 'zip'
      archiveFile: '$(Agent.TempDirectory)\$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip'
      replaceExistingArchive: true
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Zip binary files

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            if( $env:Build_SourceBranchName -eq "develop" -or 
                $env:Build_SourceBranchName -match "^release*" )
            {
              # this a dev or release branch, publish to Bintray dev repo
              Write-Host "$("##vso[task.setvariable variable=BINTRAY_REPO]")nanoframework-images-dev"
            }
            else 
            {
              # this master branch, publish to Bintray stable repo
              Write-Host "$("##vso[task.setvariable variable=BINTRAY_REPO]")nanoframework-images"
            }
        errorActionPreference: 'stop'
        failOnStderr: 'true'
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Set Bintray repo path

  - task: cURLUploader@2
    inputs:
      files: '$(Agent.TempDirectory)\$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip'
      authType: 'userAndPass'
      username: 'nfbot'
      password: '$(BinTrayKey)'
      url: 'https://api.bintray.com/'
      remotePath: 'content/nfbot/$(BINTRAY_REPO)/$(BoardName)/$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion)/$(BoardName)-$(NBGV_SimpleVersion)$(NBGV_PrereleaseVersion).zip;publish=1'
    # skip task on PR build and when on branch other than develop, master or release
    condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), or( eq(variables['Build.SourceBranchName'], 'develop'), eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) )
    displayName: Upload artifact to Bintray

#################
## WIN32 
# - job: Build_WIN32_nanoCLR
#   # skip build if this is a PR, submitted by nfbot and the commit message contains [version update]
#   condition: not( and( eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.RequestedForId'], 'nfbot'), contains(variables['Build.SourceVersionMessage'], '[version update]') ) )
#   pool:
#     vmImage: 'VS2017-Win2016'

#   steps:
#   - task: NuGetToolInstaller@0

#   - task: VSBuild@1
#     inputs:
#       solution: 'targets\os\win32\nanoCLR.sln'
#       platform: 'x86'
#       configuration: 'Release'

#######################
# generate change log
- job: Generate_change_log
  dependsOn:
  - Build_STM32_targets
  - Build_ESP32_targets
  # skip build if this is a PR, submitted by nfbot and the commit message contains [version update]
  condition: and( succeeded('Build_STM32_targets'), succeeded('Build_ESP32_targets'), not( eq(variables['Build.Reason'], 'PullRequest') ), not( and( eq(variables['Build.RequestedForId'], 'nfbot'), contains(variables['Build.SourceVersionMessage'], '[version update]') ) ) )

  pool:
    vmImage: 'VS2017-Win2016'

  steps:
  - task: DotNetCoreCLI@2  
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . nbgv
    displayName: Install NBGV tool

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: nbgv cloud -a -c
        errorActionPreference: 'silentlyContinue'
        failOnStderr: 'false'
    displayName: Set build number
    # condition: ne(variables['system.pullrequest.isfork'], true)

  - task: UseRubyVersion@0
    inputs:
      versionSpec: '>= 2.4' 
      addToPath: true

  # generate change log including future version
  - script: |
        gem install bundler
        bundle install --retry=3 --jobs=4
        gem install github_changelog_generator
        bundle exec github_changelog_generator --token $(GitHubToken) --future-release "v$(NBGV_Version)"
    condition: or( eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') )
    displayName: Generate change log

  # generate change log including future version
  - script: |
        gem install github_changelog_generator
        bundle exec github_changelog_generator --token $(GitHubToken)
    condition: not( or( eq(variables['Build.SourceBranchName'], 'master'), contains(variables['Build.SourceBranchName'], 'release') ) ) 
    displayName: Generate change log

##################################
# report build failure to Discord
- job: Report_Build_Failure
  dependsOn:
  - Build_STM32_targets
  - Build_ESP32_targets
  condition: or( failed('Build_STM32_targets'), failed('Build_ESP32_targets'))

  pool:
    vmImage: 'VS2017-Win2016'

  steps:
  - checkout: none #skip checking out the default repository resource

  - powershell: |
      .\azure-discord.ps1 failure $env:DISCORD_WEBHOOK
    env:
      DISCORD_WEBHOOK: '$(DiscordWebhook)'
    displayName: Report build error
